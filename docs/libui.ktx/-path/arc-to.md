[libui.ktx](../index.md) / [Path](index.md) / [arcTo](./arc-to.md)

# arcTo

`fun arcTo(xCenter: Double, yCenter: Double, radius: Double, startAngle: Double, sweep: Double, negative: Boolean = false): Unit`

Adds an arc to the path which is centered at ([xCenter](arc-to.md#libui.ktx.Path$arcTo(kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Boolean)/xCenter), [yCenter](arc-to.md#libui.ktx.Path$arcTo(kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Boolean)/yCenter)) position with radius [radius](arc-to.md#libui.ktx.Path$arcTo(kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Boolean)/radius)
starting at [startAngle](arc-to.md#libui.ktx.Path$arcTo(kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Boolean)/startAngle) and with sweep angle [sweep](arc-to.md#libui.ktx.Path$arcTo(kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Boolean)/sweep) going in the given direction by
anticlockwise (defaulting to clockwise) as specified by [negative](arc-to.md#libui.ktx.Path$arcTo(kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Double, kotlin.Boolean)/negative).

